// CCITT Group-4 decoder for the TIFF file format.
// 2022-05-27  T. Nakagawa

#include "TIFFG4.h"

// Finite state machine for decoding modes.
static const uint16_t fsm_mode[19] = {
  0x010b, 0x00ff, 0x01ff, 0x02ff, 0x03ff, 0xffff, 0xfeff, 0xfdff,
  0x00fe, 0x00fd, 0x00fa, 0x120c, 0x080d, 0x090e, 0x110f, 0x100a,
  0x0407, 0x0306, 0x0205,
};

// Finite state machine for white patterns.
static const uint16_t fsm_white[209] = {
  0xc56a, 0x00ff, 0x01ff, 0x02ff, 0x03ff, 0x04ff, 0x05ff, 0x06ff,
  0x07ff, 0x08ff, 0x09ff, 0x0aff, 0x0bff, 0x0cff, 0x0dff, 0x0eff,
  0x0fff, 0x10ff, 0x11ff, 0x12ff, 0x13ff, 0x14ff, 0x15ff, 0x16ff,
  0x17ff, 0x18ff, 0x19ff, 0x1aff, 0x1bff, 0x1cff, 0x1dff, 0x1eff,
  0x1fff, 0x20ff, 0x21ff, 0x22ff, 0x23ff, 0x24ff, 0x25ff, 0x26ff,
  0x27ff, 0x28ff, 0x29ff, 0x2aff, 0x2bff, 0x2cff, 0x2dff, 0x2eff,
  0x2fff, 0x30ff, 0x31ff, 0x32ff, 0x33ff, 0x34ff, 0x35ff, 0x36ff,
  0x37ff, 0x38ff, 0x39ff, 0x3aff, 0x3bff, 0x3cff, 0x3dff, 0x3eff,
  0x3fff, 0x01fe, 0x02fe, 0x03fe, 0x04fe, 0x05fe, 0x06fe, 0x07fe,
  0x08fe, 0x09fe, 0x0afe, 0x0bfe, 0x0cfe, 0x0dfe, 0x0efe, 0x0ffe,
  0x10fe, 0x11fe, 0x12fe, 0x13fe, 0x14fe, 0x15fe, 0x16fe, 0x17fe,
  0x18fe, 0x19fe, 0x1afe, 0x1bfe, 0x1cfe, 0x1dfe, 0x1efe, 0x1ffe,
  0x20fe, 0x21fe, 0x22fe, 0x23fe, 0x24fe, 0x25fe, 0x26fe, 0x27fe,
  0x28fe, 0x00fa, 0x9f6b, 0x8d6c, 0x836d, 0x806e, 0x7e6f, 0x7d70,
  0x7169, 0x7872, 0x7573, 0x745c, 0x605f, 0x7776, 0x6261, 0x6463,
  0x7a79, 0x5e5d, 0x7c7b, 0x6665, 0x6867, 0x1f1e, 0x177f, 0x2f2e,
  0x0e81, 0x8218, 0x3130, 0x8a84, 0x8785, 0x8615, 0x2322, 0x8988,
  0x2524, 0x2726, 0x028b, 0x8c14, 0x2120, 0x988e, 0x928f, 0x900d,
  0x1b91, 0x3736, 0x9693, 0x9594, 0x2928, 0x2b2a, 0x1697, 0x2d2c,
  0x0b99, 0x9c9a, 0x9b1d, 0x3f3e, 0x9e9d, 0x0140, 0x4645, 0xb3a0,
  0xa9a1, 0xa20c, 0xa5a3, 0xa41c, 0x3d3c, 0x13a6, 0xa8a7, 0x5857,
  0x5b59, 0xafaa, 0xadab, 0xac19, 0x3332, 0x1aae, 0x3534, 0x43b0,
  0xb2b1, 0x3938, 0x3b3a, 0x03b4, 0xbab5, 0xb65a, 0xb8b7, 0x4847,
  0x4ab9, 0x4c4b, 0xc1bb, 0xbebc, 0xbd49, 0x4e4d, 0xc0bf, 0x504f,
  0x5251, 0x44c2, 0xc4c3, 0x5453, 0x5655, 0xccc6, 0xc9c7, 0xc804,
  0x0942, 0x05ca, 0xcb0a, 0x1211, 0xd0cd, 0xce06, 0x41cf, 0x100f,
  0x0807,
};

// Finite state machine for black patterns.
static const uint16_t fsm_black[209] = {
  0xd06a, 0x00ff, 0x01ff, 0x02ff, 0x03ff, 0x04ff, 0x05ff, 0x06ff,
  0x07ff, 0x08ff, 0x09ff, 0x0aff, 0x0bff, 0x0cff, 0x0dff, 0x0eff,
  0x0fff, 0x10ff, 0x11ff, 0x12ff, 0x13ff, 0x14ff, 0x15ff, 0x16ff,
  0x17ff, 0x18ff, 0x19ff, 0x1aff, 0x1bff, 0x1cff, 0x1dff, 0x1eff,
  0x1fff, 0x20ff, 0x21ff, 0x22ff, 0x23ff, 0x24ff, 0x25ff, 0x26ff,
  0x27ff, 0x28ff, 0x29ff, 0x2aff, 0x2bff, 0x2cff, 0x2dff, 0x2eff,
  0x2fff, 0x30ff, 0x31ff, 0x32ff, 0x33ff, 0x34ff, 0x35ff, 0x36ff,
  0x37ff, 0x38ff, 0x39ff, 0x3aff, 0x3bff, 0x3cff, 0x3dff, 0x3eff,
  0x3fff, 0x01fe, 0x02fe, 0x03fe, 0x04fe, 0x05fe, 0x06fe, 0x07fe,
  0x08fe, 0x09fe, 0x0afe, 0x0bfe, 0x0cfe, 0x0dfe, 0x0efe, 0x0ffe,
  0x10fe, 0x11fe, 0x12fe, 0x13fe, 0x14fe, 0x15fe, 0x16fe, 0x17fe,
  0x18fe, 0x19fe, 0x1afe, 0x1bfe, 0x1cfe, 0x1dfe, 0x1efe, 0x1ffe,
  0x20fe, 0x21fe, 0x22fe, 0x23fe, 0x24fe, 0x25fe, 0x26fe, 0x27fe,
  0x28fe, 0x00fa, 0xcf6b, 0xce6c, 0xcc6d, 0xb76e, 0x9e6f, 0x7d70,
  0x7169, 0x7872, 0x7573, 0x745c, 0x605f, 0x7776, 0x6261, 0x6463,
  0x7a79, 0x5e5d, 0x7c7b, 0x6665, 0x6867, 0x8e7e, 0x857f, 0x8013,
  0x8381, 0x8235, 0x4b4a, 0x3884, 0x4d4c, 0x8b86, 0x8987, 0x8839,
  0x5554, 0x3c8a, 0x5756, 0x198c, 0x8d3d, 0x5958, 0x978f, 0x9390,
  0x911a, 0x4592, 0x5b5a, 0x9594, 0x4746, 0x3696, 0x4948, 0x4198,
  0x9b99, 0x9a37, 0x4f4e, 0x9d9c, 0x5150, 0x5352, 0xab9f, 0xa00e,
  0xa7a1, 0xa4a2, 0xa318, 0x3433, 0xa6a5, 0x2e2d, 0x302f, 0x11a8,
  0xaaa9, 0x3b3a, 0x443e, 0x0fac, 0xb1ad, 0xae12, 0xb0af, 0x3231,
  0x403f, 0xb5b2, 0xb4b3, 0x201f, 0x2221, 0x17b6, 0x2a29, 0xb9b8,
  0x0c0b, 0x0dba, 0xc2bb, 0xbc10, 0xc0bd, 0xbfbe, 0x4342, 0x1c1b,
  0x14c1, 0x1e1d, 0xc9c3, 0xc6c4, 0xc515, 0x2423, 0xc8c7, 0x2625,
  0x2827, 0x01ca, 0xcb16, 0x2c2b, 0x08cd, 0x090a, 0x0607, 0x0502,
  0x0304,
};

enum {MODE_VERTICAL = 255, MODE_HORIZONTAL = 254, MODE_PASS = 253, MODE_EOL = 250};
enum {LENGTH_TERM = 255, LENGTH_MAKEUP = 254, LENGTH_EOL = 250};

typedef union {
  uint16_t u16;
  uint8_t u8[2];
} PackedBytes;

class BitStream {
public:
  BitStream(const uint8_t *dat) : dat_(dat), ptr_(0), bit_(0x80) {
  }

  int read() {
    if (bit_ == 0) {
      ptr_++;
      bit_ = 0x80;
    }
    const uint8_t tmp = dat_[ptr_] & bit_;
    bit_ >>= 1;
    return (int)(tmp != 0);
  }

  void align() {
    bit_ = 0x00;
  }

private:
  const uint8_t *dat_;
  int ptr_;
  uint8_t bit_;
};

static uint16_t feed(const uint16_t *fsm, BitStream *bs, int state = 0) {
  PackedBytes reg;

  reg.u16 = fsm[state];
  if (reg.u8[0] >= 250) return reg.u16;
  state = reg.u8[bs->read()];
  return feed(fsm, bs, state);
}

bool tiffg4_decoder(const uint8_t *file, int width, int height, std::function<void(const uint8_t *, int)> callback) {
  if (*(uint32_t *)file != 0x002a4949) return false;	// Invalid TIFF signature.
  BitStream bs(file + 8);
  uint8_t *prv = new uint8_t[width + 1];
  uint8_t *cur = new uint8_t[width + 1];
  for (int i = 0; i < width; i++) prv[i] = 0;
  prv[width] = cur[width] = 2;	// Sentinel.
  PackedBytes reg;
  int row = 0;
  int ptr = 0;
  uint8_t clr = 0;

  while (true) {
    reg.u16 = feed(fsm_mode, &bs);
    if (reg.u8[0] == MODE_VERTICAL) {	// Vertical mode.
      int pos = ptr;
      if (!(pos == 0 && clr == 0)) while (prv[pos] == 1 - clr) pos++;
      while (prv[pos] == clr) pos++;
      pos += (int8_t)reg.u8[1];
      while (ptr < pos) cur[ptr++] = clr;
      clr = 1 - clr;
    } else if (reg.u8[0] == MODE_HORIZONTAL) {	// Horizontal mode.
      int pos = ptr;
      do {
        reg.u16 = feed(clr ? fsm_black : fsm_white, &bs);
        pos += (reg.u8[0] == LENGTH_TERM) ? reg.u8[1] : reg.u8[1] * 64;
      } while (reg.u8[0] != LENGTH_TERM);
      while (ptr < pos) cur[ptr++] = clr;
      clr = 1 - clr;
      do {
        reg.u16 = feed(clr ? fsm_black : fsm_white, &bs);
        pos += (reg.u8[0] == LENGTH_TERM) ? reg.u8[1] : reg.u8[1] * 64;
      } while (reg.u8[0] != LENGTH_TERM);
      while (ptr < pos) cur[ptr++] = clr;
      clr = 1 - clr;
    } else if (reg.u8[0] == MODE_PASS) {	// Pass mode.
      int pos = ptr;
      if (!(pos == 0 && clr == 0)) while (prv[pos] == 1 - clr) pos++;
      while (prv[pos] == clr) pos++;
      while (prv[pos] == 1 - clr) pos++;
      while (ptr < pos) cur[ptr++] = clr;
    } else {	// EOFB: Skip two EOLs and process byte alignment.
      for (int i = 0; i < 24 - 6; i++) bs.read();	// Two EOL (000000000001).
      bs.align();
      for (int i = 0; i < width; i++) prv[i] = 0;
    }

    if (ptr >= width) {
      callback(cur, row);
      if (++row >= height) break;
      ptr = 0;
      clr = 0;
      uint8_t *tmp = prv;
      prv = cur;
      cur = tmp;
    }
  }

  delete[] prv;
  delete[] cur;
  return true;
}
